// =============================================================================
// domain/src/repositories/todo_cache.rs: キャッシュ操作トレイト
// =============================================================================
// Commands からキャッシュを操作するためのインターフェース。
// クリーンアーキテクチャの依存性逆転の原則に従い、
// domain 層でトレイトを定義し、infrastructure 層で実装する。
//
// キャッシュ戦略:
// - Write-Through: 書き込み時にキャッシュも同時に更新
// - Cache Invalidation: 更新・削除時にキャッシュを無効化
//
// なぜ Reader にキャッシュ get がないのか:
// - CachedTodoReader が TodoReader をラップして透過的にキャッシュを使用
// - Commands は「キャッシュに保存」「キャッシュから削除」のみ必要
// - Queries は CachedTodoReader 経由で自動的にキャッシュを参照
// =============================================================================

// -----------------------------------------------------------------------------
// 外部クレートのインポート
// -----------------------------------------------------------------------------

// async_trait: Rust のトレイトでは直接 async fn を定義できないため、
// このマクロを使って非同期メソッドを持つトレイトを定義する。
// 内部的には async fn を Pin<Box<dyn Future>> に変換している。
use async_trait::async_trait;

// uuid: 一意識別子（Universally Unique Identifier）
// UUID v4 は 128bit のランダムな識別子を生成する。
use uuid::Uuid;

// -----------------------------------------------------------------------------
// 同一クレート内のインポート
// -----------------------------------------------------------------------------

// Todo エンティティ: キャッシュに保存するデータ構造
use crate::entities::Todo;

// DomainError: キャッシュ操作のエラーを表現
use crate::errors::DomainError;

// =============================================================================
// キャッシュ操作トレイト
// =============================================================================

/// TODO キャッシュ操作トレイト
///
/// Commands（状態変更操作）で使用するキャッシュ操作のインターフェース。
/// Write-Through パターンまたはキャッシュ無効化に使用する。
///
/// # なぜ `get` メソッドがないのか
///
/// このトレイトは Commands 専用で、読み取り操作は含まない。
/// 読み取りは `CachedTodoReader`（infrastructure 層）が担当し、
/// `TodoReader` トレイトを実装しつつ内部でキャッシュを参照する。
///
/// ```text
/// Commands:
///   CreateTodo → TodoWriter::create() → TodoCacheOps::set()
///   UpdateTodo → TodoWriter::update() → TodoCacheOps::delete()
///   DeleteTodo → TodoWriter::delete() → TodoCacheOps::delete()
///
/// Queries:
///   GetTodo → CachedTodoReader::find_by_id()
///             ↓ キャッシュヒット: キャッシュから返却
///             ↓ キャッシュミス: DB から取得 → キャッシュに保存 → 返却
/// ```
///
/// # 実装
///
/// infrastructure 層の `RedisTodoCache` が実装する。
///
/// # トレイト境界: `Send + Sync`
///
/// - `Send`: この型の所有権を別スレッドに移動可能
/// - `Sync`: この型への参照を複数スレッドで共有可能
///
/// 非同期 Web サーバーでは複数のリクエストが並行処理されるため、
/// これらの境界が必要。
#[async_trait]
pub trait TodoCacheOps: Send + Sync {
    /// TODO をキャッシュに保存する
    ///
    /// Write-Through パターンで使用。DB に書き込んだ後、
    /// 同じデータをキャッシュにも保存する。
    ///
    /// # Arguments
    /// * `todo` - キャッシュする TODO エンティティ
    ///
    /// # Returns
    /// * `Ok(())` - 成功（キャッシュ保存完了）
    /// * `Err(DomainError::Cache)` - Redis 接続エラーなど
    ///
    /// # キャッシュ設計
    ///
    /// - キー: `todo:{uuid}` 形式
    /// - 値: JSON シリアライズされた Todo
    /// - TTL: 実装に依存（例: 1時間）
    ///
    /// # エラーハンドリング
    ///
    /// キャッシュエラーは致命的ではない場合が多い。
    /// 呼び出し側で無視してもよいが、ログには記録する。
    async fn set(&self, todo: &Todo) -> Result<(), DomainError>;

    /// キャッシュから TODO を削除する（無効化）
    ///
    /// Cache Invalidation パターンで使用。TODO が更新または削除された際に、
    /// 古いキャッシュデータを無効化する。
    ///
    /// # Arguments
    /// * `id` - 削除する TODO の UUID
    ///
    /// # Returns
    /// * `Ok(())` - 成功（キャッシュ削除完了、または元々存在しない）
    /// * `Err(DomainError::Cache)` - Redis 接続エラーなど
    ///
    /// # 使用タイミング
    ///
    /// 1. `UpdateTodo` コマンド: 更新後にキャッシュ無効化
    ///    → 次回読み取り時に DB から最新データを取得
    /// 2. `DeleteTodo` コマンド: 削除後にキャッシュも削除
    ///    → 削除された TODO がキャッシュから返されることを防ぐ
    ///
    /// # 冪等性
    ///
    /// 存在しないキーを削除しても成功を返す（冪等）。
    /// これにより、複数回呼び出しても安全。
    async fn delete(&self, id: Uuid) -> Result<(), DomainError>;
}
